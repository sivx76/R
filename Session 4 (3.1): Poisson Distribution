########## Activities 1-3 #############

# Write a script (NOT A FUNCTION!) that simulates throwing balls into urns (Activity 1),
# creates a histogram of the number of balls in each urn (Activity 2),
# and prints the index of dispersion to the console (Activity 3).

# If you don't like balls and urns, you can call your variables nBees and nFlowers, 
# nVirions and nCells, or whatever you want.

print("---------------------------------------------")
print("Activities 1-3")

print("Here is the output for Activity #1, a simulation of randomly throwing 1321 balls into 93 urns.")
nBalls = 1:1321 #formerly was 1321, shifted to a vector format
nUrns = numeric(93) #is a vector of 93 zeroes

for(ball in nBalls)
{
  position_of_ball = runif(1,1,94) #notice since floor is applied, we do nUrns + 1
  #print(position_of_ball) #r often posses decimal values
  nUrns[position_of_ball] = nUrns[position_of_ball] +1 #at this position, access the value and increment it, decimal values are having floor function applied to it
  
  if (ball == 1321)  #STOP after iterating through the for loop 1321 times
  {break}
}

print(nUrns)

#v <- 1:7 |||| the purpose of this fancy set of print statements was to prove to us that R is applying the floor function to the decimal values we are obtaining from the random function
#print(v[2.4])
#print(v[2.8])
#print(v[2.999])
#print(v[3])
#print(v[0.4])


print("The scatter plot output for Activity #2 is plotted.")
hist(nUrns, 93)   #plot this


myMean <- function(b)
{
  sum = 0
  for (value in b)
  {sum = sum + value}
  average = sum / length(b)
}

myVariance = function(vector)
{
  n = length(vector) 
  mean = myMean(vector) 
  index = 1:n
  sum = 0
  
  for(position in index) 
  {
    y = (vector[position] - mean)^2 
    sum = sum + y
  }
  
  variance = (sum) / (n-1) 
  return(variance)
}


print("Here is the output for Activity #3, the variance generated by this distribution")
print(myVariance(nUrns))

######### Activities 4-5 ##############

# Now package your balls and urns script from above into a FUNCTION (Activity 4).
# Call the function throwBallsIntoUrns.
# The function should take two inputs: nBalls and nUrns. (Or nBees and nFlowers, etc.)
# Then write a SCRIPT (not a function!) to run throwBallsIntoUrns() 1000 times,
# store the indices of dispersion, and graph them in a histogram.

print("---------------------------------------------")
print("Activities 4-5")

throwBallsIntoUrns <- function(nBalls, nUrns){ #return output of index of dispersion
  
  nBalls_index = 1:nBalls #GOOD
  nUrns_numeic = numeric(nUrns) #perhaps error here, print(nUrns_numeic) = 1000 zeroes and not 30 urns
  #nUrns_numeic_plus_one = numeric(nBalls +1) #cancel this to see if function works
  
  for(ball in nBalls_index) 
  {
    position_of_ball = runif(1,1,nUrns) #not [[nUrns_numeic_plus_one]] for now
    nUrns_numeic[position_of_ball] = nUrns_numeic[position_of_ball] +1 
    
    if (ball == nBalls)  
    {break}
  } 

  #hist(nUrns_numeic, 30)

  #print("This is the variance of the data set:")
  y = var(nUrns_numeic)  ##TROUBLE MAKER: was || print(var(nUrns_numeic)) 
  print(y)
}
#  The self-generated mean and vairance functions are unneeded, will use mean and var below | would also be faster | if this function is in R environment I do not need to declare every single time


throwBallsIntoUrns(1000, 30) #this works and generates one value, the variance of the data
storage_of_indexes_dispersion = numeric(1000)
#print(storage_of_indexes_dispersion)
iterations = 1000
index = 1:iterations


for (index in 1:iterations)
{
  storage_of_indexes_dispersion[index] = throwBallsIntoUrns(1000,30) #this set all the values in the numeric() to 66.98, when I set y = throwBallsIntoUrns(1000, 30) above and put y here
}


vector_storage = c(storage_of_indexes_dispersion) #this made the statement into a vector, instead of printing out 1000 statemenets individually
print(vector_storage)
hist(vector_storage, 20)



# Question 5 asks you to think about the relationship between mean and variance.
# Type your answers in the blank print statement below
print("---------------------------------------------")
print('Answer to thought questions in #5')
print(' If we use the same number of balls and same number of urns, we will not get the same index of dispersion. The mean and variance of the data keeps changing.')






############## CoOkIe DaTa SiMuLaTiOn #############

# Make sure to include any functions (throwBallsIntoUrns, etc) that you will use.
# The line below reads in the data and stores it in the vector variable cookieData.
# Once you run this line, the variable cookieData will be defined and should show
# up in your environment pane.
source("http://labs.biology.ucsd.edu/rifkin/courses/bieb143/spr18/cookieData.R") #added this to the environment

# Declare your functions here.

print(cookieData2018)

#count number of elements in cookieData2018 to determine # of cookies
count_cookies = length(cookieData2018)
print(count_cookies) #value is 276 cookies present

#sum cookieData2018 to determine # of chips total
count_cookie_chips = sum(cookieData2018)
print(count_cookie_chips) #value is 6067 chocolate chips present
#---

mean_cookies_IOD = count_cookie_chips / count_cookies
print(mean_cookies_IOD) #we obtain 21.98 as the mean

variance_cookies_IOD = myVariance(cookieData2018)
print(variance_cookies_IOD) #we obtain 14.31 as the variance

cookies_index_of_disperstion = variance_cookies_IOD / mean_cookies_IOD
print(cookies_index_of_disperstion) #we obtain 0.65, SUCCESS!




cookie_IODs = runif(1000,0,1) #I know I want 1000 simulations, what should be max and min? || I will assume 0 will be the min and 1 will be the max.
print(cookie_IODs)

number_of_values_less_than_threshold = 0
index = 1:length(cookie_IODs)

for (run in cookie_IODs)
{
  if(run < 0.65) #assuming 0.65 is the actual value was cookie_IODs[index] instead of run
  {number_of_values_less_than_threshold = number_of_values_less_than_threshold + 1}
}
print(number_of_values_less_than_threshold)

proportion_less_threshold = number_of_values_less_than_threshold / 1000 #assuming we have 1000 IODs in vector
p_value = proportion_less_threshold  #do not need to *100, I am assuming
print("The p-value for this distribution is:")
print(p_value)

if (p_value < 0.05)
  {print('The null hypothesis is rejected.')}

if(p_value > 0.05) #I had issues getting the else statement to work
  {print('The null hypothesis is not rejected.')} #If this occurs, cannot say there is not a random cookie distribution.

# Now write code that will simulate the cookie data randomly,
# generate many indices of dispersion,
# and compare the index of dispersion of cookieData
# to the distribution of those simulated indices.
# Your code should print a p-value to the console.


#-------------------------
#-------------------------
#-------------------------
#-------------------------

# Here is a test dataset to make sure your indexOfDispersion function works:
dataForTestOfIoD=c(5,1,5,6,7,3,45,7,3,4,7,8,5,5,7,35,7,3,2,34,6,7,7,34,4,4,6)


count_length = length(dataForTestOfIoD)
print(count_length) #27 values in this vector
count_sum = sum(dataForTestOfIoD)
print(count_sum) #267 is the sum

mean_test_of_IOD = count_sum / count_length 
print(mean_test_of_IOD) #267 / 27 = 9.88

variance_test_of_IOD = myVariance(dataForTestOfIoD)
print(variance_test_of_IOD) #We obtain 139.10 as the variance

test_index_of_dispersion = variance_test_of_IOD / mean_test_of_IOD
print(test_index_of_dispersion)
# The index of dispersion should be:  14.06655 || THIS IS WHAT WE OBTAINED! SUCCESS!

#Issue: do not use throwBallsInto Urns -- calculate IOD: variance of dataForTestOfIoD / mean
#DO NOT use the formula from last week, which generates a random distribution
#DO NOT DO THIS throwBallsIntoUrns(267, 27)
# the value I obtained with this wrong function was 15.333, 11.02, 10.25 (notice how this oscillates)

