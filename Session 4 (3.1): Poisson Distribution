########## Activities 1-3 #############

# Write a script (NOT A FUNCTION!) that simulates throwing balls into urns (Activity 1),
# creates a histogram of the number of balls in each urn (Activity 2),
# and prints the index of dispersion to the console (Activity 3).

# If you don't like balls and urns, you can call your variables nBees and nFlowers, 
# nVirions and nCells, or whatever you want.

print("---------------------------------------------")
print("Activities 1-3")

print("Here is the output for Activity #1, a simulation of randomly throwing 1321 balls into 93 urns.")
nBalls = 1:1321 #formerly was 1321, shifted to a vector format
nUrns = numeric(93) #is a vector of 93 zeroes

for(ball in nBalls)
{
  position_of_ball = runif(1,1,94) #notice since floor is applied, we do nUrns + 1
  #print(position_of_ball) #r often posses decimal values
  nUrns[position_of_ball] = nUrns[position_of_ball] +1 #at this position, access the value and increment it, decimal values are having floor function applied to it
  
  if (ball == 1321)  #STOP after iterating through the for loop 1321 times
  {break}
}

print(nUrns)

#v <- 1:7 |||| the purpose of this fancy set of print statements was to prove to us that R is applying the floor function to the decimal values we are obtaining from the random function
#print(v[2.4])
#print(v[2.8])
#print(v[2.999])
#print(v[3])
#print(v[0.4])


print("The scatter plot output for Activity #2 is plotted.")
hist(nUrns, 93)   #plot this


myMean <- function(b)
{
  sum = 0
  for (value in b)
  {sum = sum + value}
  average = sum / length(b)
}

myVariance = function(vector)
{
  n = length(vector) 
  mean = myMean(vector) 
  index = 1:n
  sum = 0
  
  for(position in index) 
  {
    y = (vector[position] - mean)^2 
    sum = sum + y
  }
  
  variance = (sum) / (n-1) 
  return(variance)
}


print("Here is the output for Activity #3, the variance generated by this distribution")
print(myVariance(nUrns))

######### Activities 4-5 ##############

# Now package your balls and urns script from above into a FUNCTION (Activity 4).
# Call the function throwBallsIntoUrns.
# The function should take two inputs: nBalls and nUrns. (Or nBees and nFlowers, etc.)
# Then write a SCRIPT (not a function!) to run throwBallsIntoUrns() 1000 times,
# store the indices of dispersion, and graph them in a histogram.

print("---------------------------------------------")
print("Activities 4-5")

throwBallsIntoUrns <- function(nBalls, nUrns){ #return output of index of dispersion
  
  nBalls_index = 1:nBalls #GOOD
  nUrns_numeic = numeric(nUrns) #perhaps error here, print(nUrns_numeic) = 1000 zeroes and not 30 urns
  #nUrns_numeic_plus_one = numeric(nBalls +1) #cancel this to see if function works
  
  for(ball in nBalls_index) 
  {
    position_of_ball = runif(1,1,nUrns) #not [[nUrns_numeic_plus_one]] for now
    nUrns_numeic[position_of_ball] = nUrns_numeic[position_of_ball] +1 
    
    if (ball == nBalls)  
    {break}
  } 

  #print(nUrns_numeic) #Error before this - these are all zeroes
  hist(nUrns_numeic, 30)
  
  myMean <- function(b) #this and the next function is to calculate the index of dispersion of the distribution
  {
    sum = 0
    for (value in b)
    {sum = sum + value}
    average = sum / length(b)
  }
  
  myVariance = function(vector)
  {
    n = length(vector) 
    mean = myMean(vector) 
    index = 1:n
    sum = 0
    
    for(position in index) 
    {
      y = (vector[position] - mean)^2 
      sum = sum + y
    }
    
    variance = (sum) / (n-1) 
    return(variance)
  }  
  
  print("This is the variance of the data set:")
  print(myVariance(nUrns_numeic))
}

throwBallsIntoUrns(1000, 30)

# Question 5 asks you to think about the relationship between mean and variance.
# Type your answers in the blank print statement below
print("---------------------------------------------")
print('Answer to thought questions in #5')
print(' If we use the same number of balls and same number of urns, we will not get the same index of dispersion. The mean and variance of the data keeps changing.')
