print("Here is the output for Activity #1, a simulation of randomly throwing 1321 balls into 93 urns.")
nBalls = 1:1321 #formerly was 1321, shifted to a vector format
nUrns = numeric(93) #is a vector of 93 zeroes

for(ball in nBalls)
{
  position_of_ball = runif(1,1,94) #notice since floor is applied, we do nUrns + 1
  #print(position_of_ball) #r often posses decimal values
  nUrns[position_of_ball] = nUrns[position_of_ball] +1 #at this position, access the value and increment it, decimal values are having floor function applied to it
  
  if (ball == 1321)  #STOP after iterating through the for loop 1321 times
  {break}
}

print(nUrns)

#v <- 1:7 |||| the purpose of this fancy set of print statements was to prove to us that R is applying the floor function to the decimal values we are obtaining from the random function
#print(v[2.4])
#print(v[2.8])
#print(v[2.999])
#print(v[3])
#print(v[0.4])


print("The scatter plot output for Activity #2 is plotted.")
hist(nUrns, 93)   #plot this


myMean <- function(b)
{
  sum = 0
  for (value in b)
  {sum = sum + value}
  average = sum / length(b)
}

myVariance = function(vector)
{
  n = length(vector) 
  mean = myMean(vector) 
  index = 1:n
  sum = 0
  
  for(position in index) 
  {
    y = (vector[position] - mean)^2 
    sum = sum + y
  }
  
  variance = (sum) / (n-1) 
  return(variance)
}


print("Here is the output for Activity #3, the variance generated by this distribution")
print(myVariance(nUrns))

######### Activities 4-5 ##############

# Now package your balls and urns script from above into a FUNCTION (Activity 4).
# Call the function throwBallsIntoUrns.
# The function should take two inputs: nBalls and nUrns. (Or nBees and nFlowers, etc.)
# Then write a SCRIPT (not a function!) to run throwBallsIntoUrns() 1000 times,
# store the indices of dispersion, and graph them in a histogram.

print("---------------------------------------------")
print("Activities 4-5")

throwBallsIntoUrns <- function(      ){
  
  
  
}



